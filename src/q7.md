Choropleth graph of grouped countries using k means
Interactable scatterplot

<label for="variableSelect"><strong>Select Variable:</strong></label>
<select id="variableSelect">
    <option value="inflation, consumer prices (annual %)">Inflation</option>
    <option value="poverty headcount ratio at $6.85 a day (2017 ppp) (% of population)">Poverty Count</option>
    <option value="literacy rate, adult total (% of people ages 15 and above)">Literacy Rate</option>
    <option value="renewable energy consumption (% of total final energy consumption)">Renewable Energy</option>
    <option value="total greenhouse gas emissions excluding lulucf per capita (t co2e/capita)">Greenhouse Gas Emission</option>
</select>

<div id="my_dataviz"></div>

```js
import {darkModeColors} from "./components/colors.js";
```

```js
const prosperityData = await FileAttachment("data/prosperity_sustainability.csv").csv();
const educationData = await FileAttachment("data/education_health_gap_data.csv").csv();
const countryMeta = await FileAttachment("data/country_meta.csv").csv();
```

```js 
const metaMap = new Map(countryMeta.map(d => [d.iso3.toUpperCase(), d]));
// Create a nested map for smarter lookup: Country -> Year -> Data
const eduNested = d3.group(educationData, d => d.country);

const gdpCol = "gdp per capita (current us$)";
const renewableCol = "renewable energy consumption (% of total final energy consumption)";
const povertyCol = "poverty headcount ratio at $6.85 a day (2017 ppp) (% of population)"; 
const ghgCol = "total greenhouse gas emissions excluding lulucf per capita (t co2e/capita)";
const inflationCol = "inflation, consumer prices (annual %)";
const literacyCol = "literacy rate, adult total (% of people ages 15 and above)"; 

// Helper to safely parse numbers (returns NaN for empty strings)
function parseVal(v) {
    return (v === "" || v === null || v === undefined) ? NaN : +v;
}

function getLatestValue(country, colName, targetYear) {
    const countryData = eduNested.get(country);
    if (!countryData) return NaN;
    
    let bestVal = NaN;
    let maxYearFound = -Infinity;

    for (const row of countryData) {
        const y = +row.year;
        if (y > targetYear) continue; 
        
        const val = row[colName];
        if (val !== "" && val !== null && val !== undefined) {
             if (y > maxYearFound) {
                 maxYearFound = y;
                 bestVal = +val;
             }
        }
    }
    return bestVal;
}

const plotData = prosperityData.map(d => {
    const country = d.country;
    const year = +d.year;
    
    const meta = metaMap.get(country) || {};
    
    const povertyVal = getLatestValue(country, povertyCol, year);
    const literacyVal = getLatestValue(country, literacyCol, year);

    return {
        gdp: parseVal(d[gdpCol]),
        renewable: parseVal(d[renewableCol]),
        poverty: povertyVal,
        ghg: parseVal(d[ghgCol]),
        inflation: parseVal(d[inflationCol]),
        literacy: literacyVal,
        country: meta.country_name || country,
        region: meta.region || "Other",
        year: year
    };
}).filter(d => d.region !== "Other");

const povertyCount = plotData.filter(d => !isNaN(d.poverty)).length;
const literacyCount = plotData.filter(d => !isNaN(d.literacy)).length;
const renewableCount = plotData.filter(d => !isNaN(d.renewable)).length;

console.log(`Total plotData rows: ${plotData.length}`);
console.log(`Rows with valid Poverty: ${povertyCount}`);
console.log(`Rows with valid Literacy: ${literacyCount}`);
console.log(`Rows with valid Renewable: ${renewableCount}`);
console.log(`Example row:`, plotData[0]);

const varMap = {
    "inflation, consumer prices (annual %)": "inflation",
    "poverty headcount ratio at $6.85 a day (2017 ppp) (% of population)": "poverty",
    "literacy rate, adult total (% of people ages 15 and above)": "literacy",
    "renewable energy consumption (% of total final energy consumption)": "renewable",
    "total greenhouse gas emissions excluding lulucf per capita (t co2e/capita)": "ghg"
};

const dims = { 
    width: 800, 
    height: 500, 
    margin_top: 60, 
    margin_right: 220,
    margin_bottom: 60, 
    margin_left: 80 
}; 
function normalizeRegion(r) {
    if (!r) return "Other";
    if (r.includes("North America")) return "North America";
    if (r.includes("Europe") || r.includes("Central Asia")) return "Europe & Central Asia";
    if (r.includes("East Asia") || r.includes("Pacific")) return "East Asia & Pacific";
    if (r.includes("Latin America") || r.includes("Caribbean")) return "Latin America & Caribbean";
    if (r.includes("Middle East") || r.includes("North Africa")) return "Middle East & N. Africa";
    if (r.includes("South Asia")) return "South Asia";
    if (r.includes("Sub-Saharan Africa")) return "Sub-Saharan Africa";
    return "Other";
}

plotData.forEach(d => {
    d.region = normalizeRegion(d.region);
});
const regions = [
    "North America", "Europe & Central Asia", "East Asia & Pacific", 
    "Latin America & Caribbean", "Middle East & N. Africa", 
    "South Asia", "Sub-Saharan Africa"
]; 
const regionColor = d3.scaleOrdinal()
    .domain(regions)
    .range(darkModeColors);

d3.select("#my_dataviz").selectAll("*").remove();

const tooltip = d3.select("body").append("div")
    .attr("class", "tooltip-q7")
    .style("position", "absolute")
    .style("visibility", "hidden")
    .style("background", "white")
    .style("padding", "8px 10px")
    .style("border", "1px solid #ccc")
    .style("border-radius", "4px")
    .style("pointer-events", "none")
    .style("color", "black")
    .style("font-size", "12px")
    .style("box-shadow", "2px 2px 6px rgba(0,0,0,0.2)");

const svg = d3.select("#my_dataviz")
    .append("svg")
    .attr('width', dims.width + dims.margin_right + dims.margin_left) 
    .attr('height', dims.height + dims.margin_top + dims.margin_bottom); 

const chart = svg.append('g') 
    .attr('transform', `translate(${dims.margin_left}, ${dims.margin_top})`); 

const x_scale = d3.scaleLog()
    .domain(d3.extent(plotData, d => d.gdp))
    .range([0, dims.width])
    .nice();
let y_scale = d3.scaleLinear() 
    .domain(d3.extent(plotData, d => d.renewable))
    .range([dims.height, 0])
    .nice();

chart.append("g")
    .attr("transform", `translate(0, ${dims.height})`)
    .call(d3.axisBottom(x_scale).ticks(5, ".1s"))
    .selectAll("text")
    .style("fill", "#e0e0e0"); 

const yAxis = chart.append("g")
    .attr("class", "y-axis")
    .call(d3.axisLeft(y_scale))
    .selectAll("text")
    .style("fill", "#e0e0e0");

const yAxisGroup = chart.select(".y-axis");

chart.append("text")
    .attr("x", dims.width / 2)
    .attr("y", dims.height + 40)
    .attr("text-anchor", "middle")
    .style("font-size", "17px")
    .style("fill", "#e0e0e0")
    .text("GDP Per Capita (Log Scale)");

const yLabel = chart.append("text")
    .attr("transform", "rotate(-90)")
    .attr("x", -dims.height / 2)
    .attr("y", -50)
    .attr("text-anchor", "middle")
    .style("font-size", "17px")
    .style("fill", "#e0e0e0")
    .text("Renewable Energy");

const circles = chart.selectAll('circle')
    .data(plotData)
    .enter()
    .append('circle')
    .attr("cx", d => x_scale(d.gdp) || -1000) 
    .attr("cy", d => y_scale(d.renewable) || -1000)
    .attr("r", 5)
    .style("fill", d => regionColor(d.region))
    .style("opacity", 0.7)
    .style("stroke", "white")
    .style("stroke-width", 0.5)
    .on("mouseover", function(event, d) {
        const selectedOption = d3.select("#variableSelect").property("value");
        const key = varMap[selectedOption];
        const val = d[key];
        const formattedVal = typeof val === 'number' ? d3.format(",.2f")(val) : "N/A";
        const simpleName = selectedOption.split("(")[0].trim();

        tooltip.style("visibility", "visible")
            .html(`<b>${d.country}</b><br>Region: ${d.region}<br>GDP: $${d3.format(",.0f")(d.gdp)}<br>${simpleName}: ${formattedVal}`);
        d3.select(this).style("opacity", 1).attr("r", 7);
    })
    .on("mousemove", function(event) {
        tooltip.style("top", (event.pageY - 10) + "px")
            .style("left", (event.pageX + 10) + "px");
    })
    .on("mouseout", function() {
        tooltip.style("visibility", "hidden");
        d3.select(this).style("opacity", 0.7).attr("r", 5);
    });

const legend = svg.append("g")
    .attr("transform", `translate(${dims.margin_left + dims.width + 20}, ${dims.margin_top})`);

legend.append("text")
    .attr("x", 0)
    .attr("y", -10)
    .attr("font-size", "16px")
    .attr("font-weight", "600")
    .style("fill", "#f0f0f0")
    .text("Region");

regions.forEach((region, i) => {
    const row = legend.append("g")
        .attr("transform", `translate(0, ${i * 22 + 10})`);
    
    row.append("circle")
        .attr("cx", 6)
        .attr("cy", 0)
        .attr("r", 5)
        .attr("fill", regionColor(region))
        .attr("opacity", 0.9);
    
    row.append("text")
        .attr("x", 18)
        .attr("y", 4)
        .style("font-size", "13px")
        .style("fill", "#e0e0e0")
        .text(region);
});

function updateChart(selectedOption) {
    const key = varMap[selectedOption];
    
    const validData = plotData.filter(d => !isNaN(d[key]));
    console.log(`Variable: ${selectedOption}, Valid points: ${validData.length}`);
    if (validData.length > 0) {
        console.log("Sample data:", validData.slice(0, 5));
        console.log("Extent:", d3.extent(validData, d => d[key]));
    }

    y_scale.domain(d3.extent(validData, d => d[key])).nice();

    yAxisGroup.transition().duration(1000)
        .call(d3.axisLeft(y_scale))
        .selectAll("text")
        .style("fill", "#e0e0e0");

    circles.transition().duration(1000)
        .attr("cy", d => {
            const val = d[key];
            return isNaN(val) ? -1000 : y_scale(val);
        });

    yLabel.text(selectedOption.split("(")[0]); 
}

d3.select("#variableSelect").on("change", function(event) {
    const selectedOption = d3.select(this).property("value");
    updateChart(selectedOption);
});

updateChart(d3.select("#variableSelect").property("value"));
display(svg.node());
``` 

Across the different scatterplots, a consistent structural pattern seems to apply: countries cluster into three broad groups - low-GDP with high social/environmental stress, middle-GDP with transitional characteristics, and high-GDP with consistently low poverty but highly variable environmental impact.

In the GDP vs. Poverty plot, the clustering is especially prominent. Low-income countries are tightly grouped at the upper left, with very high poverty headcount ratios regardless of region. As GDP rises, poverty rates fall sharply, forming a middle band of transitioning economies. Eventually, high-income countries cluster near the bottom, showing minimal poverty across the board. This reflects a well-established empirical pattern: rising national income tends to reduce extreme poverty.

When examining GDP vs. Renewable Energy Use, the same three-group structure reappears, but with a crucial difference: the direction of the relationship is weaker and far more dispersed. Low-GDP countries tend to report higher renewable energy use - primarily because they rely on traditional biomass and have limited access to fossil-fuel infrastructure. Middle-income economies form a scattered mid-range cluster, while high-GDP countries spread widely across the lower half of renewable energy consumption. This dispersion indicates that economic development does not reliably predict low-carbon energy adoption; instead, energy portfolios depend on policy choices, geography, historical investment patterns, and resource endowments.

Taken together, these graphs reveal that economic success strongly correlates with improvements in social indicators like poverty reduction or literacy, but not necessarily with environmental sustainability. High GDP per capita does not guarantee lower greenhouse gas emissions or higher renewable energy adoption; in fact, many wealthy countries exhibit high emissions and low renewable shares. This suggests that environmental outcomes are not automatic byproducts of development, but rather outcomes that must be deliberately engineered through policy and technological investment.